local gd = require "game.game_data"
local gf = require "game.game_functions"
--NEED TO SET PLAYER BASED ON CLASS CHOSEN

--local clear_results_timer --maybe should just be a self variable??

function init(self)
	msg.post(".", "acquire_input_focus")

	self.player = gd.player.current_class
	self.health = self.player.health
	self.effect_table = {} --table to hold effects that last multiple turns
	gui.set_text(gui.get_node("player_health"), "Player health: "..self.health)
	
	self.move_positions = {vmath.vector3(100, 100, 0), vmath.vector3(322, 100, 0), vmath.vector3(540, 100, 0)}
	self.move_options = gf.generate_player_move_nodes(self.player, self.move_positions)

	print("player gui init done")
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		for i=1, #self.move_options do
			self.player_node_tree_selected = self.move_options[i]
			local player_node_selected = self.player_node_tree_selected[hash("player_move")]
			if gui.pick_node(player_node_selected, action.x, action.y) then
				msg.post("/game/game#game", "clear_results") --clear previous results
								
				local move_selected = self.player_node_tree_selected["move_type"] --used in player_choice message
				print("You touched the: " .. move_selected)

				msg.post("/enemy/enemy#enemy", "select_move") --tell enemy to select move
				msg.post("/game/game#game", "player_choice", {["player_move"] = move_selected}) --tell game gui what move you selected

				--remove moves as selected
				table.remove(self.move_options, i)
				gui.animate(player_node_selected, "position", vmath.vector3(320, 400, 0), gui.EASING_LINEAR, 1)

				--generate next set of moves if player runs out
				if next(self.move_options) == nil then
					self.move_options = gf.generate_player_move_nodes(self.player, self.move_positions)
				end
				break
			end
		end
	end
	
	if action_id == hash("space") then
		print("player gui spacebar")
	end
end

function final(self)
	-- Return input focus when the object is deleted
	--msg.post(".", "release_input_focus")
	print("PLAYER gui script final function done")
end

function update(self, dt)
	-- Add update code here
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	--send items to game gui script
	if message_id == hash("send_items") then
		msg.post(sender, "player_items", {shield=self.player.shield, scroll=self.player.scroll, sword = self.player.sword, special=self.player.special})
	end

	if message_id == hash("outcome_actions") then
		self.previous_node_selected = self.player_node_tree_selected[hash("player_move")] --set node to be cleared manually
		
		self.health = self.health + message.health_change

		print("prior to adding")
		pprint(self.effect_table)
		--take action on effects currently on character
		local effect_outcome = gf.trigger_effects(self.health, self.effect_table)
		self.health = effect_outcome.health
		self.effect_table = effect_outcome.effect_table

		--update effect table with new effects
		self.effect_table = gf.add_new_effects(message.effect_change, self.effect_table)
		print("after adding")
		pprint(self.effect_table)
		
		gui.set_text(gui.get_node("player_health"), "Player health: "..self.health)
		print("PLAYER hp: " ..self.health)
		if self.health <= 0 then
			msg.post("/game/game#game", "player_health_0")
		end
	end
	
	if message_id == hash("delete_previous_node") then
		gui.delete_node(self.previous_node_selected)
		self.previous_node_selected = nil
	end
	
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
