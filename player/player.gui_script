function generate_player_move_nodes(self)
	for i=1, 3 do
		local player_move = player:generate_move_option()
		local move_tree = gui.clone_tree(gui.get_node("player_move"))
		gui.set_text(move_tree[hash("move_text")], player[player_move]["name"])
		gui.set_texture(move_tree[hash("move_image")], "player_items")
		gui.play_flipbook(move_tree[hash("move_image")], player_move)
		gui.set_position(move_tree[hash("player_move")], self.move_positions[i])
		move_tree["move_type"] = player_move
		table.insert(self.move_options, move_tree)
		--pprint(move_tree)
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")

	self.move_positions = {vmath.vector3(100, 50, 0), vmath.vector3(322, 50, 0), vmath.vector3(540, 50, 0)}
	self.move_options = {}
	
	generate_player_move_nodes(self)

	print("player gui init done")
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		for i=1,3 do
			local selected_node_tree = self.move_options[i]
			local player_move_selected = selected_node_tree[hash("player_move")]
			if gui.pick_node(player_move_selected, action.x, action.y) then
				--msg.post("main:/enemy#enemy_controller", "move")
				print("You touched the " .. selected_node_tree["move_type"])
				local enemy_move_selected = master_enemy_table[1]:generate_move()
				print("Enemy has selected: " .. enemy_move_selected)
			end
		end
	end
	
	if action_id == hash("space") then
		print("player gui spacebar")
	end
end

function final(self)
	-- Return input focus when the object is deleted
	--msg.post(".", "release_input_focus")
end

function update(self, dt)
	-- Add update code here
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
