local gd = require "game.game_data"
local gf = require "game.game_functions"
--NEED TO SET PLAYER BASED ON CLASS CHOSEN



function init(self)
	msg.post(".", "acquire_input_focus")

	self.player = gd.player.current_class
	self.health = self.player.health
	self.effect_table = {} --table to hold effects that last multiple turns
	self.effect_nodes = {} --create table for clearing later
	
	gui.set_text(gui.get_node("player_health"), "Player health: "..self.health)
	
	self.move_positions = {vmath.vector3(100, 150, 0), vmath.vector3(322, 150, 0), vmath.vector3(540, 150, 0)}
	self.move_options = gf.generate_player_move_nodes(self.player, self.move_positions)

	print("player gui init done")
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		for i=1, #self.move_options do
			self.player_node_tree_selected = self.move_options[i]
			local player_node_selected = self.player_node_tree_selected[hash("player_move")]
			if gui.pick_node(player_node_selected, action.x, action.y) then
				msg.post("/game/game#game", "clear_results") --clear previous results
								
				local move_selected = self.player_node_tree_selected["move_type"] --used in player_choice message
				print("You touched the: " .. move_selected)

				msg.post("/enemy/enemy#enemy", "select_move") --tell enemy to select move
				msg.post("/game/game#game", "player_choice", {["player_move"] = move_selected}) --tell game gui what move you selected

				--remove moves as selected
				table.remove(self.move_options, i)
				gui.animate(player_node_selected, "position", vmath.vector3(320, 400, 0), gui.EASING_LINEAR, 1)

				--generate next set of moves if player runs out
				if next(self.move_options) == nil then
					self.move_options = gf.generate_player_move_nodes(self.player, self.move_positions)
				end
				break
			end
		end
	end
	
	if action_id == hash("space") then
		print("player gui spacebar")
	end
end

function final(self)
	-- Return input focus when the object is deleted
	--msg.post(".", "release_input_focus")
	print("PLAYER gui script final function done")
end

function update(self, dt)
	-- Add update code here
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	--send items to game gui script
	if message_id == hash("send_items") then
		msg.post(sender, "player_items", {shield=self.player.shield, scroll=self.player.scroll, sword = self.player.sword, special=self.player.special})
	end

	if message_id == hash("outcome_actions") then
		self.previous_node_selected = self.player_node_tree_selected[hash("player_move")] --set node to be cleared manually
		
		self.health = self.health + message.health_change

		--display numeric results color coded for gain (green) or loss (red)
		local combat_result_node = gui.get_node("combat_value")
		if tonumber(message.health_change) > 0 then
			gui.set_color(combat_result_node, vmath.vector4(0, 1, 0, 1))
			gui.set_text(combat_result_node, "HP Change: +"..message.health_change)
		elseif tonumber(message.health_change) < 0 then
			gui.set_color(combat_result_node, vmath.vector4(1, 0, 0, 1))
			gui.set_text(combat_result_node, "HP Change: "..message.health_change)
		else
			gui.set_color(combat_result_node, vmath.vector4(1, 1, 1, 1))
			gui.set_text(combat_result_node, "HP Change: "..message.health_change)
		end

		
		
		

		print("prior to adding")
		pprint(self.effect_table)
		--take action on effects currently on character
		local effect_outcome = gf.trigger_effects(self.health, self.effect_table)
		self.health = effect_outcome.health
		self.effect_table = effect_outcome.effect_table

		--update effect table with new effects
		self.effect_table = gf.add_new_effects(message.effect_change, self.effect_table)
		print("after adding")
		pprint(self.effect_table)

		--print out net changes in health from affects
		local effect_result_node = gui.get_node("effect_value")
		if tonumber(effect_outcome.hp_change) > 0 then
			gui.set_color(effect_result_node, vmath.vector4(0, 1, 0, 1))
			gui.set_text(effect_result_node, "HP Change: +"..effect_outcome.hp_change)
		elseif tonumber(effect_outcome.hp_change) < 0 then
			gui.set_color(effect_result_node, vmath.vector4(1, 0, 0, 1))
			gui.set_text(effect_result_node, "HP Change: "..effect_outcome.hp_change)
		else
			gui.set_color(effect_result_node, vmath.vector4(1, 1, 1, 1))
			gui.set_text(effect_result_node, "HP Change: "..effect_outcome.hp_change)
		end

		--clear previou effect nodes
		if next(self.effect_nodes) ~= nil then
			for i, node in pairs(self.effect_nodes) do
				gui.delete_node(node)
				table.remove(self.effect_nodes, i)
			end
		end

		--add an entry for each affect in the table
		local upper_effect_node = effect_result_node
		for _, effect in pairs(self.effect_table) do
			local new_effect_node = gui.clone(upper_effect_node)
			table.insert(self.effect_nodes, new_effect_node)
			local upper_position_y = gui.get_position(upper_effect_node)
			gui.set_position(new_effect_node, upper_position_y-vmath.vector3(0, 20,0))

			if tonumber(effect.hp_change) > 0 then
				gui.set_color(new_effect_node, vmath.vector4(0, 1, 0, 1))
				gui.set_text(new_effect_node, effect.name.." for +"..effect.hp_change.." for "..effect.duration.." turns")
			elseif tonumber(effect.hp_change) < 0 then
				gui.set_color(new_effect_node, vmath.vector4(1, 0, 0, 1))
				gui.set_text(new_effect_node, effect.name.." for "..effect.hp_change.." for "..effect.duration.." turns")
			else
				gui.set_color(new_effect_node, vmath.vector4(1, 1, 1, 1))
				gui.set_text(new_effect_node, effect.name.." for "..effect.hp_change.." for "..effect.duration.." turns")
			end
			upper_effect_node = new_effect_node
		end
		
		gui.set_text(gui.get_node("player_health"), "Player health: "..self.health)
		print("PLAYER hp: " ..self.health)
		if self.health <= 0 then
			msg.post("/game/game#game", "player_health_0")
		end
	end
	
	if message_id == hash("delete_previous_node") then
		gui.delete_node(self.previous_node_selected)
		self.previous_node_selected = nil
	end
	
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
