--url: "level_1:/enemy/enemy#enemy"
local gd = require "game.game_data"
local gf = require "game.game_functions"
-- NEED TO SET ENEMY PER LEVEL (generic way?)

function init(self)
	msg.post(".", "acquire_input_focus")

	self.enemy = nil
	self.effect_table = {}
	self.move_positions = {vmath.vector3(100, 860, 0), vmath.vector3(322, 860, 0), vmath.vector3(540, 860, 0)}
	self.move_options = nil
	
	print("enemy gui init done")
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
	print("ENEMY gui script final function done")
end

function update(self, dt)
	-- Add update code here
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	if message_id == hash("setup") then
		self.enemy = gd.enemies[message["level"]] --set enemy based on the level
		self.health = self.enemy.health
		gui.set_text(gui.get_node("enemy_health"), "Enemy health: "..self.health)
		self.move_options = gf.generate_enemy_move_nodes(self.enemy, self.move_positions)
		msg.post("/game/game#game", "enemy_setup_done")
	end

	--send items to game gui script
	if message_id == hash("send_items") then
		msg.post(sender, "enemy_items", {shield=self.enemy.shield, scroll=self.enemy.scroll, sword=self.enemy.sword, special=self.enemy.special})
	end

	--prompt enemy to select a move
	if message_id == hash("select_move") then
		local random_choice = math.random(#self.move_options)
		self.enemy_node_tree_selected = self.move_options[random_choice]
		local enemy_node_selected = self.enemy_node_tree_selected[hash("enemy_move")]

		gui.animate(enemy_node_selected, "position", vmath.vector3(320, 560, 0), gui.EASING_LINEAR, 1)

		--remove moves as selected
		table.remove(self.move_options, random_choice)

		--generate new enemy options if needed
		if next(self.move_options) == nil then
			self.move_options = gf.generate_enemy_move_nodes(self.enemy, self.move_positions)
		end
		
		local enemy_move = self.enemy_node_tree_selected["move_type"]
		print("Enemy selected: " .. enemy_move)

		msg.post("/game/game#game", "enemy_choice", {["enemy_move"] = enemy_move})
		
	end

	if message_id == hash("outcome_actions") then
		self.previous_node_selected = self.enemy_node_tree_selected[hash("enemy_move")] --set last node to be deleted manually
		
		self.health = self.health + message.health_change

		print("prior to adding")
		pprint(self.effect_table)
		--run through table, affect health accordingly and change duration
		for k, effect in pairs(self.effect_table) do
			self.health = self.health + effect.hp_change
			effect.duration = effect.duration - 1
			if effect.duration == 0 then
				table.remove(self.effect_table, k)
			end
		end

		--update effect table with ne effects

		for k, new_effect in pairs(message.effect_change) do
			print("new effect: ")
			pprint(new_effect)
			for i, current_effect in pairs(self.effect_table) do
				print("current effect: ")
				pprint(current_effect)
				if new_effect.name == current_effect.name then
					current_effect.duration = new_effect.duration
					table.remove(message.effect_change, k)
				end
			end
			table.insert(self.effect_table, new_effect)
		end

		print("after adding")
		pprint(self.effect_table)
		gui.set_text(gui.get_node("enemy_health"), "Enemy health: "..self.health)
		print("ENEMY hp: " ..self.health)
		if self.health <= 0 then
			msg.post("/game/game#game", "enemy_health_0")
		end
	end

	if message_id == hash("delete_previous_node") then
		gui.delete_node(self.previous_node_selected)
		self.previous_node_selected = nil
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
